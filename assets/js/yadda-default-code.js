// Generated by CoffeeScript 2.0.0-beta3

/**
 * @provides yadda-default-code
 */

(function() {
  window.yaddaDefaultCode = '# This is a live CoffeeScript editor affecting the Yadda interface.\n# Code will be saved to localStorage automatically if compiles.\n#\n# The entry point is "@render(state)" which returns ReactElement.\n# "state" is refreshed periodically.\n#\n# LoDash, Moment.js, React.js and Javelin are available.\n\n# Pre-defined queries\n# Change this to affect the navigation side bar\nqueries = [\n  [\'Unread\', (revs) ->\n    readMap = getReadMap()\n    revs.filter (r) -> parseInt(r.dateModified) > getDateRead(readMap, r)],\n  [\'Commented\', (revs) -> revs.filter (r) -> r.actions.some((x) -> x.comment? && x.author == user)],\n  [\'Authored\', (revs) -> revs.filter (r) -> r.author == user],\n  [\'All\', (revs) -> revs],\n]\n\n# Use selected query and repo to filter revisions\nfilterRevs = (state) ->\n  revs = state.revisions\n  # filter by repo\n  repo = state.activeRepo || \'All\'\n  if repo != \'All\'\n    revs = _.filter(revs, (r) -> r.callsign == repo)\n  # filter by query\n  entry = _.find(queries, (q) -> q[0] == state.activeQuery)\n  if entry?\n    func = entry[1]\n    if func?\n      revs = func(revs, state)\n  revs\n\n# Group by stack and sort them\ngroupRevs = (state, revs) -> # [rev] -> [[rev]]\n  allRevs = state.revisions\n  byId = _.keyBy(allRevs, (r) -> r.id)\n  getDep = _.memoize((revId) ->\n    _.min(byId[revId].dependsOn.map((i) -> getDep(i))) || revId)\n  gmap = _.groupBy(revs, (r) -> getDep(r.id))\n  # for series, sort by date\n  groupSortKey = (revs) ->\n    -_.max(revs.map((r) -> parseInt(r.dateModified)))\n  # within a series, sort by id\n  singleSortKey = (r) -> -parseInt(r.id)\n  _.map(_.sortBy(_.values(gmap), groupSortKey), (revs) ->\n    _.sortBy(revs, singleSortKey))\n\n# Current user\nuser = null\ntry\n  user = /\\/([^/]*)\\/$/.exec(document.querySelector(\'a.phabricator-core-user-menu\').href)[1]\n\n# Get repo callsigns, plus "All", sort them reasonably (shortest first)\ngetRepos = (state) ->\n  repos = _.uniq(state.revisions.map((r) -> r.callsign || \'All\'))\n  repos = _.sortBy(repos, (r) -> [r == \'All\', r.length, r])\n\n# Mark as read - record dateModified\ngetReadMap = -> # {id: dateModified}\n  result = {}\n  try\n    result = JSON.parse(localStorage[\'revRead\'])\n  result\n\nmarkAsRead = (state, revIds) ->\n  marked = getReadMap()\n  revMap = _.keyBy(state.revisions, (r) -> r.id)\n  # remove closed revisions\n  marked = _.pickBy(marked, (d, id) -> revMap[id])\n  # read dateModified\n  revIds.forEach (id) ->\n    if revMap[id]\n      marked[id] = parseInt(revMap[id].dateModified)\n  localStorage[\'revRead\'] = JSON.stringify(marked)\n\n# Get timestamp of last "marked read" or commented\ngetDateRead = (readMap, rev) ->\n  commented = _.max(rev.actions.filter((x) -> x.author == user).map((x) -> parseInt(x.dateModified))) || -1\n  marked = readMap[rev.id] || -1\n  _.max([marked, commented])\n\n# One-time normalize "state". Fill fields used by this script.\nnormalizeState = (state) ->\n  if not state.activeQuery?\n    state.activeQuery = localStorage[\'activeQuery\'] || queries[0][0]\n  if not state.activeRepo?\n    state.activeRepo = localStorage[\'activeRepo\'] || getRepos(state)[0]\n  if not state.checked?\n    state.checked = {}\n\n# Make selected rows visible\nscrollIntoView = ->\n  isVisible = (e) ->\n    top = e.getBoundingClientRect().top\n    bottom = e.getBoundingClientRect().bottom\n    top >= 0 && bottom <= window.innerHeight\n  document.querySelectorAll(\'td.selected\').forEach (e) ->\n    if not isVisible(e)\n      e.scrollIntoView()\n\n# Keyboard shortcuts\ninstallKeyboardShortcuts = (state, grevs) ->\n  if !JX? || !JX.KeyboardShortcut?\n    return\n  if not state.keyNext?\n    (state.keyNext = new JX.KeyboardShortcut([\'j\'], \'Select next stack\')).register()\n  if not state.keyPrev?\n    (state.keyPrev = new JX.KeyboardShortcut([\'k\'], \'Select previous stack\')).register()\n  if not state.keyNextSingle?\n    (state.keyNextSingle = new JX.KeyboardShortcut([\'J\'], \'Select next revision\')).register()\n  if not state.keyPrevSingle?\n    (state.keyPrevSingle = new JX.KeyboardShortcut([\'K\'], \'Select previous revision\')).register()\n  if not state.keySelAll?\n    (state.keySelAll = new JX.KeyboardShortcut([\'*\'], \'Select all in current view\')).register()\n  if not state.keyToggle?\n    k = (new JX.KeyboardShortcut([\'x\'], \'Toggle checkboxes for selected revisions\')).setHandler ->\n      checked = not ((state.currRevs || []).some (r) -> state.checked[r])\n      (state.currRevs || []).forEach (r) -> state.checked[r] = checked\n      state.set()\n    (state.keyToggle = k).register()\n  if not state.keyOpen?\n    k = (new JX.KeyboardShortcut([\'o\'], \'Open a revision in new tab\')).setHandler ->\n      r = _.min(state.currRevs)\n      if r\n        window.open("/D#{r}", \'_blank\')\n    (state.keyOpen = k).register()\n  if not state.keyMarkRead?\n    k = (new JX.KeyboardShortcut([\'a\'], \'Mark selected revisions as read\')).setHandler ->\n      markAsRead state, _.keys(_.pickBy(state.checked))\n      state.set \'checked\', {}\n    (state.keyMarkRead = k).register()\n  toId = (r) -> r.id\n  getRevIds = (singleSelection) ->\n    if singleSelection\n      _.flatten(_.values(grevs)).map((r) -> [r.id])\n    else\n      _.values(grevs).map((rs) -> rs.map(toId))\n  getIndex = (revIds) ->\n    currRevs = state.currRevs || []\n    _.findIndex(revIds, (rs) -> _.intersection(rs, currRevs).length > 0) || 0\n  [[true, state.keyNextSingle, state.keyPrevSingle], [false, state.keyNext, state.keyPrev]].forEach (x) ->\n    [single, next, prev] = x\n    next.setHandler ->\n      revIds = getRevIds(single)\n      i = getIndex(revIds)\n      state.set \'currRevs\', revIds[_.min([i + 1, revIds.length - 1])] || []\n      setTimeout scrollIntoView, 100\n    prev.setHandler ->\n      revIds = getRevIds(single)\n      i = getIndex(revIds)\n      state.set \'currRevs\', revIds[_.max([i - 1, 0])] || []\n      setTimeout scrollIntoView, 100\n  state.keySelAll.setHandler ->\n    state.set \'currRevs\', _.flatten(_.values(grevs)).map(toId)\n\n# Transaction to human readable text\ndescribeAction = (action) ->\n  verb = {\n    \'inline\': \'commented inline\'\n    \'comment\': \'commented\'\n    \'update\': \'updated the code\'\n    \'accept\': \'accepted\'\n    \'reject\': \'rejected\'\n    \'close\': \'closed the revision\'\n    \'resign\': \'resigned as reviewer\'\n    \'abandon\': \'abandoned the revision\'\n    \'reclaim\': \'reclaimed the revision\'\n    \'reopen\': \'reopened the revision\'\n    \'plan-changes\': \'planned changes\'\n    \'commandeer\': \'commandeered the revision\'\n  }[action.type]\n  if not verb\n    return\n  desc = "#{action.author} #{verb}"\n  if action.comment\n    if action.comment.includes(\'\\n\')\n      desc += ": #{action.comment.split(\'\\n\')[0]}..."\n    else\n      desc += ": #{action.comment}"\n  desc\n\n# React elements\n{a, button, div, input, li, span, strong, style, table, tbody, td, th, thead, tr, ul} = React.DOM\n\nrenderQueryList = (state) ->\n  ul className: \'phui-list-view\',\n    li className: \'phui-list-item-view phui-list-item-type-label\',\n      span className: \'phui-list-item-name\', \'Queries\'\n    queries.map (q, i) ->\n      name = q[0]\n      selected = (state.activeQuery == name)\n      li key: name, className: "phui-list-item-view phui-list-item-type-link #{selected and \'phui-list-item-selected\'}",\n        a className: \'phui-list-item-href\', href: \'#\', onClick: (-> state.set \'activeQuery\', name; localStorage[\'activeQuery\'] = name),\n          span className: \'phui-list-item-name\', name\n\nrenderRepoList = (state) ->\n  repos = getRepos(state)\n  ul className: \'phui-list-view\',\n    li className: \'phui-list-item-view phui-list-item-type-label\',\n      span className: \'phui-list-item-name\', \'Repos\'\n    repos.map (name, i) ->\n      selected = (state.activeRepo == name)\n      li key: name, className: "phui-list-item-view phui-list-item-type-link #{selected and \'phui-list-item-selected\'}",\n        a className: \'phui-list-item-href\', href: \'#\', onClick: (-> state.set \'activeRepo\', name; localStorage[\'activeRepo\'] = name),\n          span className: \'phui-list-item-name\', name\n\nrenderProfile = (state, username, opts = {}) ->\n  profile = state.profileMap[username]\n  a _.extend({className: "profile", title: profile.realName, href: "/p/#{username}", style: {backgroundImage: "url(#{profile.image})"}}, opts)\n\nrenderActivities = (state, rev, actions) ->\n  author = className = title = actionId = \'\'\n  elements = []\n  append = ->\n    # [author, className, title, actionId] = buf\n    if author\n      elements.push span key: actionId,\n        renderProfile state, author, href: "/D#{rev.id}##{actionId}", title: title, className: "#{className} profile action"\n    author = className = title = actionId = \'\'\n  _.sortBy(actions, (x) -> parseInt(x.dateCreated)).forEach (x) ->\n    if parseInt(x.dateCreated) <= parseInt(rev.dateCreated) # do not show actions creating a revision\n      return\n    if x.author != author\n      append()\n    author = x.author\n    if [\'accept\', \'reject\', \'update\'].includes(x.type)\n      className = x.type # the latest action wins\n    desc = describeAction(x)\n    if desc\n      title += "#{desc}\\n"\n    if !actionId or parseInt(x.id) < actionId\n      actionId = parseInt(x.id)\n  append()\n  elements\n\nrenderTable = (state, grevs) ->\n  ago = moment().subtract(3, \'days\') # display relative time within 3 days\n  currRevs = _.keyBy(state.currRevs || [])\n  readMap = getReadMap() # {id: dateModified}\n  table className: \'aphront-table-view\',\n    thead null,\n      tr null,\n        th style: {width: 4, padding: \'8px 0px\'}, \'\'  # selection indicator\n        th style: {width: 10}, \'\' # checkbox\n        th null, \'Revision\'\n        th colSpan: 2, style: {textAlign: \'center\'}, title: \'Read | Unread\', \'Activities\'\n        th style: {width: 20, textAlign: \'right\'}, \'Size\'\n        th style: {width: 20}, \'Updated\'\n    grevs.map (subgrevs, i) ->\n      lastAuthor = null # dedup same author\n      tbody key: i,\n        subgrevs.map (r) ->\n          mtime = moment.unix(parseInt(r.dateModified))\n          lines = parseInt(r.lineCount)\n          atime = getDateRead(readMap, r)\n          actions = r.actions\n          readActions = actions.filter((x) -> parseInt(x.dateModified) <= atime)\n          unreadActions = actions.filter((x) -> parseInt(x.dateModified) > atime)\n          tr key: r.id, className: "#{(atime >= parseInt(r.dateModified)) && \'read\' || \'not-read\'} #{state.checked[r.id] && \'selected\'}",\n            td className: "#{currRevs[r.id] && \'selected\' || \'not-selected\'}"\n            td null,\n              input type: \'checkbox\', checked: (state.checked[r.id] || false), onChange: (e) ->\n                state.checked[r.id] = !state.checked[r.id]\n                state.set()\n                e.target.blur()\n              if r.author != lastAuthor\n                lastAuthor = r.author\n                renderProfile(state, r.author)\n            td className: \'title\', title: r.summary,\n              strong null, "D#{r.id} "\n              a href: "/D#{r.id}",\n                strong null, r.title\n            td className: \'read-actions\',\n              renderActivities state, r, readActions\n            td className: \'unread-actions\',\n              renderActivities state, r, unreadActions\n            td null,\n              span className: \'size\', style: {width: lines / 7.2}, title: "#{lines} lines"\n            [mtime].map (time, i) ->\n              td key: i, title: time.format(\'LLL\'),\n                if time > ago\n                  time.fromNow()\n                else\n                  time.format(\'MMM D\')\n\nstylesheet = """\n.yadda .aphront-table-view td { padding: 3px 4px; }\n.yadda td input { display: inline-block; vertical-align: middle; margin: 3px 5px; }\n.yadda td.selected, .yadda td.not-selected { padding: 0px 2px; }\n.yadda td.selected { background: #3498db; }\n.yadda tbody { border-bottom: 1px solid #dde8ef }\n.yadda tbody:last-child { border-bottom: transparent; }\n.yadda span.size { height: 10px; background: #3498db; display: inline-block; float: right }\n.yadda .profile { width: 20px; height: 20px; display: inline-block; vertical-align: middle; background-size: cover; background-position: left-top; background-repeat: no-repeat; background-clip: content-box;}\n.yadda .profile.action { margin-right: 2px; }\n.yadda .profile.accept, .yadda .profile.reject, .yadda .profile.update { height: 15px; padding-bottom: 1px; }\n.yadda .profile.accept { border-bottom: 4px solid #139543; }\n.yadda .profile.reject { border-bottom: 4px solid #C0392B; }\n.yadda .profile.update { border-bottom: 4px solid #3498DB; }\n.yadda td.read-actions { text-align: right; opacity: 0.5; max-width: 200px; overflow: auto; border-right: 1px dashed #dde8ef; padding-right: 1px; }\n.yadda tr.read { background: #E2EEF5; }\n.yadda tr.selected { background-color: #FDF3DA; }\n"""\n\n@render = (state) ->\n  normalizeState state\n  revs = filterRevs(state, state.revisions)\n  grevs = groupRevs(state, revs)\n  installKeyboardShortcuts state, grevs\n  # Uncomment below and use F12 tool to see "state" structure\n  # window.s = state\n  div className: \'yadda\',\n    style null, stylesheet\n    div className: \'phui-navigation-shell phui-basic-nav\',\n      div className: \'phabricator-nav\',\n        div className: \'phabricator-nav-local phabricator-side-menu\',\n          renderQueryList state\n          renderRepoList state\n        div className: \'phabricator-nav-content mlt mll mlr mlb\',\n          renderTable state, grevs';

}).call(this);
